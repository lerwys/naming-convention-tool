package org.openepics.names.model;

import com.google.common.base.Preconditions;

import javax.annotation.Nullable;
import javax.persistence.Entity;
import javax.persistence.ManyToOne;
import java.util.Date;

/**
 * A revision of a Device entity representing its state at some point in time.
 *
 * @author Marko Kolar <marko.kolar@cosylab.com>
 */
@Entity
public class DeviceRevision extends Persistable {

    private @ManyToOne Device device;

    private @ManyToOne UserAccount requestedBy;

    private Date requestDate;

    private boolean deleted;

    private @ManyToOne NamePart section;

    private @ManyToOne NamePart deviceType;

    private @Nullable String instanceIndex;

    private String conventionName;

    private String conventionNameEqClass;

    protected DeviceRevision() {}

    /**
     * @param device the device the revision pertains to
     * @param requestDate the time when the revision was proposed
     * @param requestedBy the user that proposed the revision. Null if the revision was generated by an automated
     * process.
     * @param deleted a flag signifying that the revision represents deletion of the device
     * @param section the section containing the device
     * @param deviceType the type of the device
     * @param instanceIndex an additional identifier that, in combination with other attributes, determine the unique
     * convention name of the device. Null if omitted.
     * @param conventionName the full name of the device in accordance with the naming convention
     * @param conventionNameEqClass the representative of the equivalence class the convention name belongs to. This is
     * used to ensure uniqueness of convention names when treating similar looking names (for example, containing 0 vs.
     * O, 1 vs. l) as equal.
     */
    public DeviceRevision(Device device, Date requestDate, @Nullable UserAccount requestedBy, boolean deleted, NamePart section, NamePart deviceType, @Nullable String instanceIndex, String conventionName, String conventionNameEqClass) {
        Preconditions.checkNotNull(device);
        Preconditions.checkNotNull(requestDate);
        Preconditions.checkNotNull(section);
        Preconditions.checkNotNull(deviceType);
        Preconditions.checkArgument(instanceIndex == null || !instanceIndex.isEmpty());
        Preconditions.checkArgument(conventionName != null && !conventionName.isEmpty());
        Preconditions.checkArgument(conventionNameEqClass != null);
        this.device = device;
        this.requestedBy = requestedBy;
        this.requestDate = requestDate;
        this.deleted = deleted;
        this.section = section;
        this.deviceType = deviceType;
        this.instanceIndex = instanceIndex;
        this.conventionName = conventionName;
        this.conventionNameEqClass = conventionNameEqClass;
    }

    /**
     * The device the revision pertains to.
     */
    public Device getDevice() { return device; }

    /**
     * The time when the revision was proposed.
     */
    public Date getRequestDate() { return requestDate; }

    /**
     * The user that proposed the revision. Null if the revision was generated by an automated process.
     */
    public @Nullable UserAccount getRequestedBy() { return requestedBy; }

    /**
     * A flag signifying that the revision represents deletion of the device.
     */
    public boolean isDeleted() { return deleted; }

    /**
     * The section containing the device.
     */
    public NamePart getSection() { return section; }

    /**
     * The type of the device.
     */
    public NamePart getDeviceType() { return deviceType; }

    /**
     * An additional identifier that, in combination with other attributes, determine the unique convention name of the
     * device. Null if omitted.
     */
    public @Nullable String getInstanceIndex() { return instanceIndex; }

    /**
     * The full name of the device in accordance with the naming convention.
     */
    public String getConventionName() { return conventionName; }

    /**
     * The representative of the equivalence class the convention name belongs to. This is used to ensure uniqueness of
     * convention names when treating similar looking names (for example, containing 0 vs. O, 1 vs. l) as equal.
     */
    public String getConventionNameEqClass() { return conventionNameEqClass; }
}
